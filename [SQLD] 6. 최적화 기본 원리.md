
# 옵티마이저 
![](https://images.velog.io/images/yuhayung7296/post/661e7a24-f15d-4a26-9a09-90b4bad48d5f/image.png)
## 규칙기반 옵티마이저 
: 규칙(우선순위)를 가지고 실행계획을 생성한다.

## 비용기반 옵티마이저
: SQL문을 처리하는데 필요한 비용이 가장 적은 실행 계획을 선택하는 방식 

---

# 실행계획 

> - 실행계획은 SQL 처리를 위한 실행 절차와 방법을 표현한 것이다.
- 실행계획은 조인 방법, 조인 순서, 엑세스 기법 등이 표현된다.
- CBO의 실행계획에는 단계별 예상 비용및 건수 등이 표시된다. 
- ORACLE의 규칙기반 옵티마이저에서 가장 우선 순위가 높은 규칙은 Single row by rowid 엑세스 기법이다. 
- 비용기반 옵티마이저는 테이블, 인덱스, 칼럼등 객체의 통계정보를 사용하여 실행계획을 수립하므로 통계정보가 변경되면 SQL의 실행계획이 달라질 수 있다. 
- ORACLE의 실행계획에 나타나는 기본적인 Jion 기법으로는 NL Join, Hash Join, Sort Merge Join 등이 있다.

## 실행계획 정보의 구성 요소 
![](https://images.velog.io/images/yuhayung7296/post/3f827d27-0b23-4a10-ab21-e235833d93de/image.png)



## 실행계획 실행 순서 

![](https://images.velog.io/images/yuhayung7296/post/dede6c86-890d-4143-b9d5-00800f3069bf/image.png)

[출처 + 도움이 되는 글 📌](https://m.blog.naver.com/PostView.nhn?blogId=genie319&logNo=100147787477&proxyReferer=https:%2F%2Fwww.google.com%2F)

➡️ 실행계획을 읽는 순서 : 위 -> 아래 / 안 -> 밖 

---

# SQL 처리 흐름도

![](https://images.velog.io/images/yuhayung7296/post/d8ad7462-af95-4b82-a0d8-096ffc972a7f/image.png)

- 인덱스 스캔, 테이블 전체 스캔등 같은 엑세스 기법이 표현된다.
- 성능적인 측면도 표현 할 수 있다.
- SQL의 내부적인 처리 절차를 시각적으로 표현해 준다.
- SQL 처리 흐름도만 보고 실행 시간을 알 수 없다. 
- 실행계획과 관련이 있다. 

(인덱스 범위 스캔은 결과 건수 만큼 반환하시만, 결과가 없으면 한 건도 반환하지 않을 수 있다. )

---

# 인덱스 Index 
- 인덱스의 목적은 조회 성능을 최적화 하는 것이다.
- Insert, Update, Delete 등의 DML 처리 성능을 저하시킬 수도 있다. 
- B-TREE 인덱스는 일치 및 범위 검색에 적절한 구조이다.
- 인덱스는 INSERT와 DELETE 작업과는 다르게 UPDATE 작업에는 부하가 없을 수도 있다. 
- SQL Server의 클러스터형 인덱스는 ORACLE의 IOT와 매우 유사하다.
- 인덱스를 활용하여 데이터를 조회할 때 인덱스를 구성하는 칼럼들의 순서는 SQL 실행 과 관계가 있다. 

## 관계형 데이터베이스 인덱스
- 기본 인텍스에 널 값(Null Value) 들이 나타날 수 없다.
- 테이블의 전체 데이터를 읽는 경우 인덱스가 거의 불필요하다.
- B-TREE는 관계형 데이터베이스의 주요 인덱스 구조이다.

## B-TREE 인덱스
: 브랜치 블록과 리프 블록으로 구성되며. 브랜치 블록은 분기를 목적으로 하로 리프블록은 인덱스를 구성하는 컬럼의 값으로 정렬된다.
일반적으로 OLTP 시스템 환경에서 많이 사용된다. 

## CLUSTERED 인덱스
: 인덱스의 리프 페이지가 곧 데이터 페이지이며, 리프 페이지의 모든 데이터는 인덱스 키 칼럼 순으로 물리적으로 정렬되어 저장된다. 

## BITMAP 인덱스 
: 시스템에서 사용될 질의를 시스템 구현 시에 모두 알 수 없는 경우인 DW 및 AD-HOC 질의 환경을 위해서 설계되었으며, 하나의 인덱스 키 엔트리가 많은 행에 대한 포인터를 저장하고 있는 구조이다. 

---

# JOIN 
## Sort Merge Join 
- 칼럼을 기준으로 데이터를 정렬하여 조인을 수행한다. 
- 스캔 방식으로 데이터를 읽는다. 
- Non - EQUL JOIN 조건에도 사용할 수 있다.

## Nested Loop Join
- 랜덤 액세스 방식으로 데이터를  읽는다. 
- Driving Table의 조인 데이터 양이 큰 영향을 주는 조인 방식이다. 
- 유니크 인덱스를 활용하여 수행시간이 적게 걸리는 소량 테이블을 온라인 조회하는 경우 유용하다. 

## Hash Join
- 칼럼의 인덱스를 사용하지 않는다. 
- 조인 칼럼의 인덱스가 존재하지 않을 경우 사용할수 있는 조인 기법이다.
- Hash Join은 해쉬함수를 이용하여 조인을 수행하기 때문에 '='로 수행하는 조인 즉, 동등 조인에서만 사용할 수 있다.
- 소트머지조인을 수행하기에 두 테이블이 너무 커서 소트 부하가 심할때 사용하면 좋다. 
- EQUL JOIN 에서만 동작하는 JOIN 방식이다.



---

여기 까지 SQLD 자격시험 범위이다.. 
우와.. 하루종일 매달려 1 ~ 6 까지 정리했다. 

이제 일주일 동안 달달 외우고 
나머지 일주일은 기출 풀고 시험보러 가야지 .; 

🙌🏻
